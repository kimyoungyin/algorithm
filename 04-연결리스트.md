# 연결리스트

## 연결 리스트의 성질(배열과 비교해보자)

-   메모리 상의 배치가 불연속
-   K번째 원소를 확인/변경: O(K)
-   임의의 위치에 원소를 추가/제거: O(1)
-   원소들이 메모리 상에 연속해있지 않아 Cache hit rate가 낮지만 할당이 다소 쉬움

## 연결 리스트의 종류

-   단일 연결 리스트
-   이중 연결 리스트
-   원형 연결 리스트

## 연결 리스트의 구현

Node 구조체나 클래스를 만들어서 원소가 생성될 때마다 동적 생성한다.

c++에서는 STL list를 사용하면 되지만 Javascript는 코딩테스트에서 직접 구현해야 한다.

하지만,,, 실무에서는 공간 복잡도를 고려해 전혀 사용하지 않아도 코딩테스트에서 활용 가능한 '야매 연결 리스트'를 구현해보면 다음과 같다

### 야매 연결 리스트

-   이전/다음이 없음은 -1로 표현한다.
-   첫 Node는 dummy node로, 첫 요소의 에외처리를 하지 않기 위해 관념적으로 사용한다. (-1, -1, 첫 번쨰 노드 주소)
    -   덕분의 어떤 요소이든 `pre[addr]`는 -1인 경우가 없다

```js
const data = []; // 데이터 저장 배열
const pre = []; // addr의 데이터 이전 주소
const nxt = []; // addr의 데이터 다음 주소
let unused = 1; // 새로운 원소가 들어갈 addr

// 순회
const traverse = () => {
    let cur = nxt[0]; // 시작 주소. dummy node의 nxt가 연결리스트의 시작점이다.
    let answer = "";
    while (cur != -1) {
        answer += dat[cur] + " ";
        cur = nxt[cur];
    }
    console.log(answer);
};

// 삽입: 주소가 addr인 노드 다음에 value를 삽입한다.
const insert = (addr, value) => {
    // 노드 생성
    data[unused] = value;
    pre[unused] = addr;
    nxt[unused] = nxt[addr];
    // 기존 노드 조작
    nxt[addr] = unused;
    // 예외: nxt 노드가 없을 때
    if (nxt[addr] !== -1) pre[nxt[addr]] = unused;
    unused++;
};

const erase = (addr) => {
    // 중요: 메모리 누수는 있지만 해당 addr의 데이터는 건드리지 않는다
    // addr 이전 노드의 다음 노드는 addr 다음 노드
    nxt[pre[addr]] = nxt[addr];
    // addr 다음 노드의 이전 노드는 addr 이전 노드
    if (nxt[addr] !== -1) pre[nxt[addr]] = pre[addr];
};
```
