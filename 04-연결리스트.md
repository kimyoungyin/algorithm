# 연결리스트

## 연결 리스트의 성질(배열과 비교해보자)

-   메모리 상의 배치가 불연속
-   K번째 원소를 확인/변경: O(K)
-   임의의 위치에 원소를 추가/제거: O(1)
-   원소들이 메모리 상에 연속해있지 않아 Cache hit rate가 낮지만 할당이 다소 쉬움

## 연결 리스트의 종류

-   단일 연결 리스트
-   이중 연결 리스트
-   원형 연결 리스트

## 연결 리스트의 구현

Node 구조체나 클래스를 만들어서 원소가 생성될 때마다 동적 생성한다.

c++에서는 STL list를 사용하면 되지만 Javascript는 코딩테스트에서 직접 구현해야 한다.

### 연결리스트 구현 시 유의사항 및 팁

-   보통 스택 자료구조를 사용해서 구현하기 쉬운 경우가 많다.
-   새로운 노드를 추가할 때는 연결을 먼저 한 후 연결리스트의 정보를 변경하자: push, unshift, insert 등
-   예외사항을 조심하자: 연결리스트가 비어있거나, 하나인 경우(`this.head === this.tail`)
-   상황에 따라 `return this`를 통해 새로운 연결리스트를 반환하자

```js
// 예시
class Node {
    constructor(data) {
        this.data = data;
        // this.prev = null; // 양방향인 경우
        this.next = null;
    }
}

class SingleLinkedList {
    constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    traverse() {
        let cur = this.head;
        let line = "";
        while (cur) {
            line += cur.data + " ";
            cur = cur.next;
        }
        console.log(line);
    }
    push(data) {
        const newNode = new Node(data);
        if (!this.head) {
            this.head = newNode;
            this.tail = this.head;
        } else {
            this.tail.next = newNode; // 현재 tail의 다음 노드를 새 노드로
            this.tail = newNode; // 새 노드가 tail이 되도록 수정
        }
        this.length++;
        return this; // 변경된 연결리스트 반환
    }
    pop() {
        // 아예 빈 경우
        if (!this.head) return;

        let cur = this.head;
        let newTail = cur;
        while (cur.next) {
            newTail = cur;
            cur = cur.next;
        }
        this.tail = newTail;
        this.tail.next = null;
        this.length--;
        if (this.length === 0) {
            this.head = null;
            this.tail = null;
        }
        return cur;
    }
    // 맨 앞의 요소를 제거
    shift() {
        // 아예 비어있음: return undefined;
        if (!this.head) return undefined;
        const shifted = this.head;
        if (this.head === this.tail) {
            // 하나만 있음: head return 후 head, tail null;
            this.head = null;
            this.tail = null;
            return shifted;
        } else {
            // 둘 이상: this.head 저장. this.head = this.head.next
            this.head = this.head.next;
            shifted.next = null;
        }
        this.length--;
        return shifted;
    }
    unshift(data) {
        const newNode = new Node(data);
        if (!this.head) {
            this.head = newNode;
            this.tail = this.head;
        } else {
            newNode.next = this.head;
            this.head = newNode;
        }
        this.length++;
        return this;
    }
}
```
