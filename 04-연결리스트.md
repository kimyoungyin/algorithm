# 연결리스트

## 연결 리스트의 성질(배열과 비교해보자)

-   메모리 상의 배치가 불연속
-   K번째 원소를 확인/변경: O(K)
-   임의의 위치에 원소를 추가/제거: O(1)
-   원소들이 메모리 상에 연속해있지 않아 Cache hit rate가 낮지만 할당이 다소 쉬움

## 연결 리스트의 종류

-   단일 연결 리스트
-   이중 연결 리스트
-   원형 연결 리스트

## 연결 리스트의 구현

Node 구조체나 클래스를 만들어서 원소가 생성될 때마다 동적 생성한다.

c++에서는 STL list를 사용하면 되지만 Javascript는 코딩테스트에서 직접 구현해야 한다.

하지만,,, 실무에서는 공간 복잡도를 고려해 전혀 사용하지 않아도 코딩테스트에서 활용 가능한 '야매 연결 리스트'를 구현해보면 다음과 같다

### 야매 연결 리스트

-   이전/다음이 없음은 -1로 표현한다.
-   첫 Node는 dummy node로, 첫 요소의 에외처리를 하지 않기 위해 관념적으로 사용한다. (-1, -1, 첫 번쨰 노드 주소)
    -   덕분의 어떤 요소이든 `pre[addr]`는 -1인 경우가 없다

```js
const MX = 10000;
const data = Array(MX).fill(0);
const prev = Array(MX).fill(-1);
const next = Array(MX).fill(-1);
let unused = 1; // 0은 dummy

// 순회
const traverse = () => {
    let cur = next[0]; // 시작 주소
    let answer = "";
    while (cur !== -1) {
        answer += data[cur] + " ";
        cur = next[cur];
    }
    console.log(answer.trim());
};

// 삽입: addr 뒤에 char 삽입
const insert = (addr, char) => {
    data[unused] = char;

    next[unused] = next[addr];
    prev[unused] = addr;
    if (next[addr] !== -1) prev[next[addr]] = unused;
    next[addr] = unused;

    unused++;
};

// 삭제
const erase = (addr) => {
    next[prev[addr]] = next[addr];
    if (next[addr] !== -1) prev[next[addr]] = prev[addr];
};
```

## 연결 리스트를 이용해야 하는 문제들

-   N이 5000정도로 작다면 O(N2)으로 짜도 무방 -> 배열로 구현
-   N이 매우 크다면 -> 연결 리스트 구현
