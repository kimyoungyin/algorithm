# 자료구조 관점에서 배열

## 배열의 성질

-   O(1)에 k번째 원소를 확인/변경 가능
-   추가적으로 소모되는 메모리의 양(=overhead)가 거의 없음
-   Cache hit rate가 높음
-   메모리 상에 연속한 구간을 잡아야 해서 할당에 제약이 걸림

## 배열의 연산과 시간 복잡도

-   임의의 원소 확인/변경: O(1)
-   원소를 끝에 추가/제거: O(1)
-   임의의 위치에 원소를 추가/제거: O(N)

> 사실 javascript는 splice를 활용하면 쉽게 원본 배열을 변경할 수 있다.
> [Array.prototype.splice()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)

```js
// insert 구현
const arr = [1, 3, 5, 6, 8];

const insert = (idx, el, arr) => {
    arr.splice(idx, 0, el);
};

insert(2, 11, arr);

console.log(arr);
```

```js
// erase 구현
const arr = [1, 3, 5, 6, 8];

const erase = (idx, arr) => {
    arr.splice(idx, 1);
};

erase(2, arr);

console.log(arr);
```

## 아이디어

-   빈도수: 빈도수를 저장하는 0으로 초기화된 배열을 미리 만들어둘 것

    -   서로 다른 수가 있는 배열에서 합이 100이 되는 두 수가 존재하는가?

        ```js
        const arr1 = [1, 52, 48];
        const arr2 = [50, 42];
        const arr3 = [4, 13, 63, 87];

        const solution = (arr) => {
            const freq = {};
            let answer = 0;
            for (let el of arr) {
                if (freq[100 - el]) {
                    answer = 1;
                    break;
                }
                freq[el] = 1;
            }
            console.log(answer);
        };

        solution(arr1);
        solution(arr2);
        solution(arr3);
        ```
