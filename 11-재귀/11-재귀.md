# 재귀를 시작하기 전에..!

매우 어려우니까 기존에 알던 생각을 과감히 깨야 이해가 쉬울 것!

# 재귀란?

-   하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘

## 수학적 귀납법(귀납적 사고)

도미노를 넘어뜨린다고 생각해보자. 왜 모든 도미노가 넘어질까?

-   절차 지향적 사고: 1번 도미노가 넘어지면 2번 도미노가 넘어지고, 2번 도미노가 넘어지면 3번 도미노가 넘어지고... 결국 모든 도미노가 넘어진다
-   귀납적 사고: k번 도미노가 넘어지면 k+1번째 도미노가 넘어진다.

## 귀납적 사고 활용하기

해당 함수가 왜 n부터 1까지 모두 출력하는 함수가 있다고 가정하다. 이를 어떻게 입증할까? (절차지향적 사고는 단순히 함수의 흐름을 따라가보면 된다.)

```js
function func1(n) {
    if (n === 0) return;
    console.log(n);
    fun1(n - 1);
}
```

> 조건 1: func1(1)이 1을 출력한다.
> 입증해야 할 것: func1(k)가 k k-1 k-2 ... 1을 출력하면(가정) func1(k + 1)은 k+1 k k-1 ... 1을 출력함(결과)

### `func1(k+1)`을 살펴보기

1. k+1 출력
2. func1(k)호출 = k k-1 k-2 ... 1 출력(가정)
3. 그러므로 func1(k+1)은 K+1부터 1까지 출력함

# 재귀함수의 조건

-   특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 함(Base condition)
-   모든 입력은 base condition으로 수렴해야 함

# 재귀함수에 대한 정보/팁

-   재귀는 함수를 '명확히' 정의해야 함. 인자로 어떤 것을 받고 어디까지 진행할 지
-   모든 재귀 함수는 '반복문'만으로 동일한 동작을 하는 함수를 만들 수 있다
-   재귀는 '반복문'으로 구현했을 때에 비해 '코드는 간결' BUT '메모리/시간' 손해
-   자기 자신을 여러 번 호출하게 되면 비효율적일 수 있음. 예시 - 피보나치 수열을 재귀로 구현할 경우
-   재귀함수가 자기 자신을 부를 때 '스택' 영역에 계속 누적이 됨
