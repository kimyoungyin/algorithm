# 큐

-   front(head): 원소의 제거 위치
-   rear(tail): 원소의 추가 위치

## 큐의 성질

-   FIFO
-   원소의 추가 O(1)
-   원소의 제거 O(1)
-   제일 앞/뒤의 원소 확인 O(1)
-   제일 앞/뒤가 아닌 나머지 원소들의 확인/변경은 원칙적으로 불가능

## 큐 구현하기

-   배열로 구현할 수 있다. 다만 직접 Node로 구현하는 것도 좋다.
    -   속도는 노드로 구성된 큐 >= 관념적 head 이동으로 구현한 큐배열 > 그냥 배열
-   자료구조 직접 구현하기
    -   push: tail 위치 뒤로 이동
    -   pop: head 위치 뒤로 이동
    -   주의: 계속 자료구조가 우측으로 이동하여 쓸데없는 공간이 생길 수 있음. 관념적으로 원형 큐로 만들어도 됨
-   배열로 구현하기: 다만, 배열의 맨 앞 요소를 제거하는 방식은 Javascript에서 그리 효율적인 방법은 아닐 수 있음을 유의.

    -   push: `Array.prototype.push` 사용
    -   pop: `Array.prototype.shift` 사용

-   보통 큐를 활용해서 알고리즘 문제를 풀어야 하는 경우 배열을 이용하더라도 대부분 통과하는 경우가 많다.
-   그러나 시간 복잡도를 매우 세세하게 관리해야 하는 경우라던가, 데이터의 양이 매우 큰 경우에는 이 같은 방식으로는 통과할 수 없는 경우가 종종 있다. 따라서 이런 경우에 직접 구현한 큐를 이용하여 더 빠른 시간 복잡도로 문제에 접근한다면 통과할 수 있는 확률이 올라갈 것이다.

> [큐 직접 구현 vs Array 메서드(shift, splice)](https://velog.io/@grap3fruit/JS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%AC%ED%98%84-%ED%81%90Queue-%EA%B5%AC%ED%98%84%ED%96%88%EC%9D%84%EB%95%8C-vs-Array-%EB%A9%94%EC%84%9C%EB%93%9Cshift-splice-%EC%82%AC%EC%9A%A9%ED%96%88%EC%9D%84%EB%95%8C-%EC%86%8D%EB%8F%84-%EB%B9%84%EA%B5%90)

```js
const MX = 1000005;
const q = Array.from({ length: MX }, () => 0);
let head = 0,
    tail = 0;
// 실무에서는 이렇게 쓸 이유는 없지만, 코딩테스트에서는 push 횟수가 정해져 있기 때문에 직접 선형 큐로 구현해보자.
function push(el) {
    q[tail++] = el;
}

function pop() {
    head++;
}

function front() {
    return q[head];
}

function back() {
    return q[tail - 1];
}
```
